Imports System.Runtime.CompilerServices

Namespace Functional.Queueing
    '''<summary>Describes a thread-safe call queue for non-blocking calls.</summary>
    Public Interface ICallQueue
        '''<summary>Queues a subroutine to be run and returns a future for the subroutine's eventual completion.</summary>
        Function QueueAction(ByVal action As Action) As IFuture
    End Interface

    Public Module QueueExtension
        '''<summary>Queues a function to be run and returns a future for the function's eventual output.</summary>
        <Extension()> Public Function QueueFunc(Of R)(ByVal queue As ICallQueue, ByVal func As Func(Of R)) As IFuture(Of R)
            If queue Is Nothing Then Throw New ArgumentNullException("queue")
            If func Is Nothing Then Throw New ArgumentNullException("func")
            Dim f As New Future(Of R)
            queue.QueueAction(Sub() f.SetValue(func()))
            Return f
        End Function
    End Module

    ''' <summary>
    ''' Runs queued calls in order.
    ''' Logs unexpected exceptions from queued calls.
    ''' </summary>
    Public MustInherit Class BaseCallQueue
        Implements ICallQueue
        Private ReadOnly lock As New Object() 'Synchronizes access to all variables
        Private ReadOnly calls As New Queue(Of CallQueueCall) 'Queue of calls to run
        Private running As Boolean 'Indicates if calls are running

        Private Class CallQueueCall
            Public ReadOnly [call] As Action
            Public ReadOnly future As Future
            Public Sub New(ByVal [call] As Action, ByVal f As Future)
                Me.call = [call]
                Me.future = f
            End Sub
        End Class

        '''<summary>
        '''Queues a subroutine to be run and returns a future for the subroutine's eventual completion.
        '''Starts running calls from the queue if they were not already being run.
        '''</summary>
        Public Function QueueAction(ByVal action As Action) As IFuture Implements ICallQueue.QueueAction
            If action Is Nothing Then Throw New ArgumentNullException("action")
            Dim f As New Future
            SyncLock lock
                calls.Enqueue(New CallQueueCall(action, f))
                If running Then Return f
                running = True
            End SyncLock
            StartRunning()
            Return f
        End Function

        '''<summary>Must call Run to start emptying the queue, and must not block the calling thread (eg. call Run on a new thread).</summary>
        Protected MustOverride Sub StartRunning()

        '''<summary>Runs queued calls until there are none left.</summary>
        Protected Sub Run()
            Dim bq = New Queue(Of CallQueueCall) 'buffer queue
            Do
                'Buffer calls
                SyncLock lock
                    'Stop running if queue empty
                    If calls.Count <= 0 Then
                        running = False
                        Return
                    End If
                    'Copy queued calls to non-synced buffer queue
                    Do
                        bq.Enqueue(calls.Dequeue)
                    Loop While calls.Count() > 0
                End SyncLock

                'Run buffered calls
                Do
                    With bq.Dequeue()
                        Try
                            Call .call()
                        Catch ex As Exception
                            Logging.LogUnexpectedException("Exception rose past Call Queue Run ({0}, {1})".frmt(Me.GetType.Name), ex)
                        End Try
                        .future.SetReady()
                    End With
                Loop While bq.Count() > 0
            Loop
        End Sub
    End Class

    ''' <summary>
    ''' A multiple-producer, single-consumer queue for running actions in order.
    ''' Logs unexpected exceptions from queued calls.
    ''' </summary>
    ''' <remarks>
    ''' The consumer is generated by the producers when items to consume exist and no consumer exists.
    ''' The queue should never end up non-empty and potentially permanently non-consumed.
    ''' </remarks>
    Public MustInherit Class BaseLockFreeCallQueue
        Inherits BaseConsumingLockFreeCallQueue(Of Node)
        Implements ICallQueue
        Public Class Node
            Public ReadOnly action As Action
            Public ReadOnly future As New future
            Public Sub New(ByVal action As Action)
                Me.action = action
            End Sub
        End Class

        '''<summary>
        '''Queues a subroutine to be run and returns a future for the subroutine's eventual completion.
        '''Starts running calls from the queue if they were not already being run.
        '''</summary>
        Public Function QueueAction(ByVal action As Action) As IFuture Implements ICallQueue.QueueAction
            Dim n = New Node(action)
            EnqueueConsume(n)
            Return n.future
        End Function

        '''<summary>Runs queued calls until there are none left.</summary>
        Protected Overrides Sub Consume(ByVal item As Node)
            Try
                Call item.action()
            Catch ex As Exception
                Logging.LogUnexpectedException("Exception rose past {0}.Run()".frmt(Me.GetType.Name), ex)
            End Try
            Call item.future.SetReady()
        End Sub
    End Class

    '''<summary>Runs queued calls on a control's thread.</summary>
    Public Class InvokedCallQueue
        Inherits BaseLockFreeCallQueue
        Private ReadOnly control As Control
        Public Sub New(ByVal control As Control)
            Me.control = ContractNotNull(control, "control")
        End Sub
        Protected Overrides Sub StartRunning()
            Try
                control.BeginInvoke(Sub() Run())
            Catch e As InvalidOperationException
                Logging.LogUnexpectedException("Invalid Invoke from {0}.StartRunning() ({1}, {2})".frmt(Me.GetType.Name, control.GetType.Name, control.Name), e)
            End Try
        End Sub
    End Class

    '''<summary>Runs queued calls on an independent thread.</summary>
    Public Class ThreadedCallQueue
        Inherits BaseLockFreeCallQueue
        Private ReadOnly thread_name As String
        Public Sub New(Optional ByVal thread_name As String = Nothing)
            Me.thread_name = thread_name
        End Sub
        Protected Overrides Sub StartRunning()
            ThreadedAction(Sub() Run(), thread_name)
        End Sub
    End Class

    '''<summary>Runs queued calls on the thread pool.</summary>
    Public Class ThreadPooledCallQueue
        Inherits BaseLockFreeCallQueue
        Protected Overrides Sub StartRunning()
            ThreadPooledAction(Sub() Run())
        End Sub
    End Class
End Namespace
